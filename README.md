# ObserverDemo
观察者模式两种实现方式
第一种方式 具体观察持有被观察的主题对象，在构造具体观察者实例时候，会把this对象添加到主题对象里，主题对象和观察者紧密集合
第二种方式 具体观察者不持有被观察的主题对象，通过调用主题对象的attach方法 逐个添加观察者对象，
推拉 模式。。。。

      
通常我们希望把压力分散到各个客户端上去，服务端只做最核心的事情，只提供内容，不管理分发列表；

“推”的好处包括：

1、高效。如果没有更新发生，不会有任何更新消息推送的动作，即每次消息推送都发生在确确实实的更新事件之后，都是有意义的。

2、实时。事件发生后的第一时间即可触发通知操作。

3、可以由Subject确立通知的时间，可以避开一些繁忙时间。

4、可以表达出不同事件发生的先后顺序。

 

“拉”的好处包括：

1、如果观察者众多，Subject来维护订阅者的列表，可能困难，或者臃肿，把订阅关系解脱到Observer去完成。

2、Observer可以不理会它不关心的变更事件，只需要去获取自己感兴趣的事件即可。

3、Observer可以自行决定获取更新事件的时间。

4、拉的形式可以让Subject更好地控制各个Observer每次查询更新的访问权限。

 

----------------------------------------------------------------------------------------------------------------------------------

2012-2-27 补充：

事实上“推”和“拉”可以比较的内容太多了，比如：

客户端通常是不稳定的，服务端是稳定的，如果消息由客户端主动发起去获取，它很容易找到服务端的地址，可以比较容易地做到权限控制（集中在服务端一处），服务端也可以比较容易地跟踪客户端的位置和状态，反之则不行；

互联网页面的访问就是一个最好的“拉”的模式的例子；

通常我们希望把压力分散到各个客户端上去，服务端只做最核心的事情，只提供内容，不管理分发列表；

……

还有一个idea是关于“推”和“拉”结合的形式，例如，服务端只负责通知某一些数据已经准备好，至于是否需要获取和什么时候客户端来获取这些数据，完全由客户端自行确定。
